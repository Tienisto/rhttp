// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'client.dart';
import 'error.dart';
import 'http.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'stream.dart';
part 'websocket.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `connect_websocket`, `frame_to_message`, `map_ws_error`, `message_to_frame`, `run_websocket_task`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `fmt`, `fmt`

Future<WebSocketHandle> websocketConnect({
  RequestClient? client,
  ClientSettings? settings,
  required HttpMethod method,
  required String url,
  List<(String, String)>? query,
  HttpHeaders? headers,
  HttpBody? body,
  Dart2RustStreamReceiver? bodyStream,
}) => RustLib.instance.api.crateApiWebsocketWebsocketConnect(
  client: client,
  settings: settings,
  method: method,
  url: url,
  query: query,
  headers: headers,
  body: body,
  bodyStream: bodyStream,
);

Future<void> websocketClose({required WebSocketHandle handle}) =>
    RustLib.instance.api.crateApiWebsocketWebsocketClose(handle: handle);

Stream<RhttpWebSocketEvent> websocketListen({
  required WebSocketHandle handle,
}) => RustLib.instance.api.crateApiWebsocketWebsocketListen(handle: handle);

Future<void> websocketSend({
  required WebSocketHandle handle,
  required RhttpWebSocketMessage msg,
}) => RustLib.instance.api.crateApiWebsocketWebsocketSend(
  handle: handle,
  msg: msg,
);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WebSocketHandle>>
abstract class WebSocketHandle implements RustOpaqueInterface {}

@freezed
sealed class RhttpWebSocketEvent with _$RhttpWebSocketEvent {
  const RhttpWebSocketEvent._();

  const factory RhttpWebSocketEvent.message(
    RhttpWebSocketMessage field0,
  ) = RhttpWebSocketEvent_Message;
  const factory RhttpWebSocketEvent.closed({
    int? code,
    String? reason,
  }) = RhttpWebSocketEvent_Closed;
  const factory RhttpWebSocketEvent.error(
    WebSocketError field0,
  ) = RhttpWebSocketEvent_Error;
}

@freezed
sealed class RhttpWebSocketMessage with _$RhttpWebSocketMessage {
  const RhttpWebSocketMessage._();

  const factory RhttpWebSocketMessage.text(
    String field0,
  ) = RhttpWebSocketMessage_Text;
  const factory RhttpWebSocketMessage.binary(
    Uint8List field0,
  ) = RhttpWebSocketMessage_Binary;
  const factory RhttpWebSocketMessage.ping(
    Uint8List field0,
  ) = RhttpWebSocketMessage_Ping;
  const factory RhttpWebSocketMessage.pong(
    Uint8List field0,
  ) = RhttpWebSocketMessage_Pong;
  const factory RhttpWebSocketMessage.close({
    required int code,
    required String reason,
  }) = RhttpWebSocketMessage_Close;
}
